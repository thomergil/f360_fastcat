#!/usr/bin/env ruby
# frozen_string_literal: true

require 'optparse'
require 'logger'

# Constants
DEFAULT_SAFE_HEIGHT        = 15.0
MIN_SAFE_HEIGHT           = 1.0
DEFAULT_TRAVEL_FEEDRATE    = 300
CLEARANCE_OFFSET          = 0.5
TOOL_CHANGE_PREFIX        = '(Tool change sequence for file'
COMMAND_STOP_SPINDLE      = 'M5'
COMMAND_RETRACT           = 'G0 Z'
COMMAND_HOME_Z            = 'G28 G91 Z0'
COMMAND_ABSOLUTE_MODE     = 'G90'

#
# Main class
#
# This class is responsible for reading and processing G-code files generated by Fusion 360.
# It will optimize the G-code by removing redundant commands and adding tool change sequences.
# The tool change sequence is added when a tool change is detected between files.
# The safe height is determined by analyzing the maximum Z values in each file.
# The safe height can be overridden by the user.
# The fast mode will optimize non-cutting moves by applying travel feedrate to them.
# The dry run mode will display the output without writing to a file.
# The output file will contain a concatenated version of the input files with optimized G-code.
class FusionGCodeFixer
  def initialize(input_files, verbose: false, fast: false, safe_height_override: nil, dry_run: false, travel_feedrate: DEFAULT_TRAVEL_FEEDRATE)
    @input_files = input_files
    @verbose = verbose
    @fast = fast
    @travel_feedrate = travel_feedrate
    @safe_height_override = safe_height_override
    @dry_run = dry_run
    @tool_numbers = {} # Cache for tool numbers
    @logger = Logger.new($stdout)
    @logger.level = verbose ? Logger::INFO : Logger::WARN
    @logger.formatter = proc { |_severity, _datetime, _progname, msg| "#{msg}\n" }

    validate_files
  end

  def validate_files
    @input_files.each do |file|
      unless File.readable?(file)
        raise ArgumentError, "Cannot read file: #{file}"
      end
    end
  end

  def get_tool_number(file)
    @tool_numbers[file] ||= begin
      tool_info = { number: nil, description: nil }
      File.readlines(file).each do |line|
        if line =~ /\(T(\d+)\s+([^)]+)\)/
          tool_info[:number] = ::Regexp.last_match(1).to_i
          tool_info[:description] = ::Regexp.last_match(2).strip
          return tool_info
        end
      end
      tool_info
    end
  end

  # Find maximum Z height in a file
  def find_max_z_height(lines)
    max_z = 0
    lines.each do |line|
      if line =~ /\bZ([-\d.]+)/
        z_value = ::Regexp.last_match(1).to_f
        max_z = z_value if z_value > max_z
      end
    end
    @logger.info("Found maximum Z height: #{max_z}mm")
    max_z
  end

  # Extract Z value from a G-code line
  def get_z_value(line)
    if line =~ /\bZ([-\d.]+)/
      z_value = ::Regexp.last_match(1).to_f
      return z_value
    end
    nil
  end

  # Set the feed rate for a G-code line
  def set_line_feedrate(line, feedrate)
    stripped = line.strip

    if stripped =~ /F[\d.]+/
      # Replace existing feedrate
      new_line = stripped.gsub(/F[\d.]+/, "F#{feedrate}")
      @logger.info("Modified feedrate: #{new_line}")
    else
      # Add feedrate if not present
      new_line = "#{stripped} F#{feedrate}"
      @logger.info("Added feedrate: #{new_line}")
    end

    new_line
  end

  def tool_change_sequence(file_number, safe_height)
    [
      '',
      "#{TOOL_CHANGE_PREFIX} #{file_number + 1})",
      COMMAND_STOP_SPINDLE,
      'M0 (Pause for tool change)',
      "#{COMMAND_RETRACT}#{safe_height}",
      COMMAND_HOME_Z,
      COMMAND_ABSOLUTE_MODE,
      ''
    ]
  end

  def process_file(file, index, safe_height)
    lines = File.readlines(file).map(&:rstrip)
    travel_threshold_height = safe_height
    current_tool = index.zero? ? nil : get_tool_number(@input_files[index - 1])
    last_file = (index == @input_files.size - 1)
    comment = "(BEGIN FILE: #{File.basename(file)})"
    next_tool = get_tool_number(file)

    # If tools are different, we need a full header G-codes
    needs_header = index.zero? || (current_tool && next_tool && current_tool[:number] != next_tool[:number])

    output = []
    output << "\n" if index.positive?
    output << comment

    # If tool is changing, add tool change sequence
    if needs_header && !index.zero?
      @logger.info("Tool change detected from T#{current_tool[:number]} (#{current_tool[:description]}) to T#{next_tool[:number]} (#{next_tool[:description]})")
      output.concat(tool_change_sequence(index, safe_height))
    elsif index.positive?
      @logger.info("No tool change detected between file #{index} and file #{index + 1}")
      # For same tool transitions, add a safe retract
      output.concat([
        '(Safe retract)',
        "G0 Z#{safe_height}", # Safe retract
        ''
      ])
    end

    # Variables for feed rate optimization
    in_travel = false
    previous_feedrate = nil
    first_line_after_travel = false
    mode_set = false
    first_move = false

    lines.each do |line|
      stripped = line.strip
      next if stripped.empty?

      # Skip program start/end markers
      next if stripped == '%' # Program start/end marker
      next if stripped == 'M30' && !last_file # Program end and rewind command; keep it at the end

      # Always skip comments
      next if stripped.start_with?('(')   # Skip all comments
      next if stripped.match?(/^G28/)     # Skip homing commands

      if stripped.match?(/^G90/)          # Skip absolute mode if already set
        next if mode_set
        mode_set = true
      end
      if stripped.match?(/^G91/)          # Skip relative mode if already set
        next if mode_set
        mode_set = true
      end

      # For files using the same tool, skip redundant initialization codes:
      unless needs_header
        # Skip common setup G-codes:
        next if stripped.match?(/^G17/) # Skip XY plane selection
        next if stripped.match?(/^G21/) # Skip metric units declaration
        next if stripped.match?(/^G54/) # Skip work coordinate system selection

        # Skip tool and spindle related commands:
        next if stripped.start_with?('T') # Tool selection commands
        next if stripped.start_with?('M') && !last_file && !stripped.start_with?('M3')
      end

      # Track first movement command
      if !first_move && stripped.start_with?('G0', 'G1', 'X', 'Y', 'Z')
        first_move = true
      end

      # Store the original line for processing
      new_line = stripped

      # Check for feedrate in the line
      if stripped =~ /F([\d.]+)/
        previous_feedrate = ::Regexp.last_match(1).to_f
        @logger.info("Found feedrate: #{previous_feedrate}")
      end

      # Process G0 moves
      if stripped.start_with?('G0') && @fast
        z_value = get_z_value(stripped)
        if z_value.nil? || z_value >= travel_threshold_height
          # If no Z movement or Z is high enough, use travel feedrate
          new_line = set_line_feedrate(stripped, @travel_feedrate)
        end
      end

      # Process G1 moves with feed rate optimization
      if stripped.start_with?('G1')
        z_value = get_z_value(stripped)

        if z_value
          if z_value >= travel_threshold_height
            @logger.info("Z >= threshold (#{z_value} >= #{travel_threshold_height}), using travel feedrate")
            new_line = set_line_feedrate(stripped, @travel_feedrate)
            in_travel = true
          else
            if in_travel
              @logger.info("Z < threshold (#{z_value} < #{travel_threshold_height}), no longer in travel")
              first_line_after_travel = true
              in_travel = false
            end
          end
        end

        if in_travel
          # Apply travel feedrate to all moves during travel
          new_line = set_line_feedrate(stripped, @travel_feedrate)
        elsif first_line_after_travel && !(stripped =~ /F[\d.]+/) && previous_feedrate
          # Restore previous feedrate for first move after travel
          new_line = set_line_feedrate(stripped, previous_feedrate)
          first_line_after_travel = false
        end
      end

      # Add the processed line to output
      output << new_line
    end

    # Add mandatory safe retract at end of file (except last file)
    # This ensures the tool moves up before transitioning to the next operation
    unless last_file
      last_line = lines.reverse.find { |l| l =~ /\bZ([-\d.]+)/ }
      last_z_position = last_line ? get_z_value(last_line) : nil
      if !last_z_position || last_z_position < travel_threshold_height
        output << '(End of file safe retract with travel feedrate)'
        output << "G0 Z#{safe_height} F#{@travel_feedrate}"
      end
    end

    output
  end

  def concatenate
    # If safe height is explicitly provided, use it
    if @safe_height_override
      safe_height = @safe_height_override
    else
      # Analyze safe height from ALL files to find the global maximum Z
      max_z_across_all_files = 0

      @input_files.each do |file|
        file_lines = File.readlines(file).map(&:rstrip)
        file_max_z = find_max_z_height(file_lines)
        max_z_across_all_files = file_max_z if file_max_z > max_z_across_all_files
      end

      # Calculate safe height from global max Z value
      if max_z_across_all_files < MIN_SAFE_HEIGHT
        @logger.warn("No valid Z moves found across all files, defaulting to #{DEFAULT_SAFE_HEIGHT}mm")
        safe_height = DEFAULT_SAFE_HEIGHT
      else
        safe_height = max_z_across_all_files - CLEARANCE_OFFSET
        @logger.info("Calculated safe height from global max Z (#{max_z_across_all_files}mm): #{safe_height}mm")
      end
    end

    # Always enforce minimum safe height
    if safe_height < MIN_SAFE_HEIGHT
      @logger.warn("Safe height too low, using minimum: #{MIN_SAFE_HEIGHT}mm")
      safe_height = MIN_SAFE_HEIGHT
    end

    # Add extra logging to help debug safe height issues
    @logger.warn("USING SAFE HEIGHT: #{safe_height}mm for all operations")

    final_output = []
    @input_files.each_with_index do |file, idx|
      processed = process_file(file, idx, safe_height)
      final_output.concat(processed)
    end

    # Add program start/end markers
    final_output.unshift('%')  # Start of program
    final_output.push('%')     # End of program

    final_output
  end

  def save_output(output_file)
    final_output = concatenate
    if final_output.empty? || final_output.none? { |line| line =~ /\bG\d+\b/ }
      raise 'Sanity check failed: Output does not contain any G-code commands.'
    end

    if @dry_run
      @logger.info('Dry run mode enabled. The following output would be written:')
      puts final_output.join("\n")
    else
      File.write(output_file, final_output.join("\n"))
    end
  end
end

options = {
  verbose: false,
  fast: false,
  safe_height: nil,
  dry_run: false,
  travel_feedrate: DEFAULT_TRAVEL_FEEDRATE
}

opt_parser = OptionParser.new do |opts|
  opts.banner = "Usage: #{$PROGRAM_NAME} [options] input_file1 [input_file2 ...] output_file"
  opts.on('-v', '--verbose', 'Enable verbose mode') { options[:verbose] = true }
  opts.on('--fast', 'Enable fast mode (optimize non-cutting moves)') { options[:fast] = true }
  opts.on('--safe-height VALUE', Float, 'Override safe height/travel threshold (in mm)') { |v| options[:safe_height] = v }
  opts.on('--travel-feedrate VALUE', Float, 'Set feed rate for travel moves (mm/min)') { |v| options[:travel_feedrate] = v }
  opts.on('--dry-run', 'Dry run mode: display output without writing to file') { options[:dry_run] = true }
end

opt_parser.parse!

if ARGV.size < 2
  puts opt_parser
  exit 1
end

output_file = ARGV.pop
input_files = ARGV

fixer = FusionGCodeFixer.new(
  input_files,
  verbose: options[:verbose],
  fast: options[:fast],
  safe_height_override: options[:safe_height],
  dry_run: options[:dry_run],
  travel_feedrate: options[:travel_feedrate]
)
fixer.save_output(output_file)
puts "Output written to #{output_file}" unless options[:dry_run]
